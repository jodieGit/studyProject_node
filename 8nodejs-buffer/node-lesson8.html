<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Node.js Buffer(缓冲区)</title>
    <link rel="stylesheet" href="http://www.runoob.com/wp-content/themes/runoob/style.css?v=1.02" type="text/css" media="all">
</head>
<body>
    <p>javascript语言本身只有字符串数据类型，没有二进制数据类型。</p>
    <p>但是在处理TCP流或者文件流时，必须使用到二进制数据。因此在Node.js中，定义了一个Buffer类，该类用来创建一个专门存放二进制数据的缓存区。</p>
    <p>在Node.js中，Buffer类是随Node内核一起发布的核心库。Buffer为Node.js带来了一种存储原始数据的方法，可以让Node.js处理二进制数据，每当需要node.js中处理I/O操作
    中移动的数据时，就有可能使用Buffer库。原始数据存储在Buffer类的实例中，一个Buffer类似于一个整数数组，但它对应于V8堆内存之外的一块原始内存</p>

    <table class="reference">
        <tbody><tr><th>序号</th><th>方法 &amp; 描述</th></tr>
        <tr><td>1</td><td><b>new Buffer(size)</b> <br>分配一个新的 size 大小单位为8位字节的 buffer。  注意, size 必须小于 kMaxLength，否则，将会抛出异常 RangeError。</td></tr>
        <tr><td>2</td><td><b>new Buffer(buffer)</b> <br>拷贝参数 buffer 的数据到 Buffer 实例。</td></tr>
        <tr><td>3</td><td><b>new Buffer(str[, encoding])</b><br> 分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 'utf8'。</td></tr>
        <tr><td>4</td><td><b>buf.length</b><br> 返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。</td></tr>
        <tr><td>5</td><td><b>buf.write(string[, offset[, length]][, encoding])</b><br>根据参数 offset 偏移量和指定的 encoding 编码方式，将参数 string 数据写入buffer。 offset 偏移量默认值是 0, encoding 编码方式默认是 utf8。 length 长度是将要写入的字符串的 bytes 大小。 返回 number 类型，表示写入了多少 8 位字节流。如果 buffer 没有足够的空间来放整个 string，它将只会只写入部分字符串。 length 默认是 buffer.length - offset。 这个方法不会出现写入部分字符。</td></tr>
        <tr><td>6</td><td><b>buf.writeUIntLE(value, offset, byteLength[, noAssert])</b><br>将value 写入到 buffer 里， 它由offset 和 byteLength 决定，支持 48 位计算，例如：<br>
<pre class="prettyprint prettyprinted"><span class="kwd">var</span><span class="pln"> b </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Buffer</span><span class="pun">(</span><span class="lit">6</span><span class="pun">);</span><span class="pln">
b</span><span class="pun">.</span><span class="pln">writeUIntBE</span><span class="pun">(</span><span class="lit">0x1234567890ab</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">6</span><span class="pun">);</span><span class="pln">
</span><span class="com">// &lt;Buffer 12 34 56 78 90 ab&gt;</span></pre>
            noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr>
        <tr><td>7</td><td><b>buf.writeUIntBE(value, offset, byteLength[, noAssert])</b><br>将value 写入到 buffer 里， 它由offset 和 byteLength 决定，支持 48 位计算。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr>
        <tr><td>8</td><td><b>buf.writeIntLE(value, offset, byteLength[, noAssert])</b><br>将value 写入到 buffer 里， 它由offset 和 byteLength 决定，支持 48 位计算。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr>
        <tr><td>9</td><td><b>buf.writeIntBE(value, offset, byteLength[, noAssert])</b><br>将value 写入到 buffer 里， 它由offset 和 byteLength 决定，支持 48 位计算。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr>
        <tr><td>10</td><td><b>buf.readUIntLE(offset, byteLength[, noAssert])</b><br>支持读取 48 位以下的数字。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr>
        <tr><td>11</td><td><b>buf.readUIntBE(offset, byteLength[, noAssert])</b><br>支持读取 48 位以下的数字。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr>
        <tr><td>12</td><td><b>buf.readIntLE(offset, byteLength[, noAssert])</b><br>支持读取 48 位以下的数字。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr>
        <tr><td>13</td><td><b>buf.readIntBE(offset, byteLength[, noAssert])</b><br>支持读取 48 位以下的数字。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr>
        <tr><td>14</td><td><b>buf.toString([encoding[, start[, end]]])</b><br>根据 encoding 参数（默认是 'utf8'）返回一个解码过的 string 类型。还会根据传入的参数 start (默认是 0) 和 end (默认是 buffer.length)作为取值范围。</td></tr>
        <tr><td>15</td><td><b>buf.toJSON()</b><br>将 Buffer 实例转换为 JSON 对象。</td></tr>
        <tr><td>16</td><td><b>buf[index]</b><br>获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。</td></tr>
        <tr><td>17</td><td><b>buf.equals(otherBuffer)</b><br>比较两个缓冲区是否相等，如果是返回 true，否则返回 false。</td></tr>
        <tr><td>18</td><td><b>buf.compare(otherBuffer)</b><br>比较两个 Buffer 对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。</td></tr>
        <tr><td>19</td><td><b>buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</b><br>buffer 拷贝，源和目标可以相同。 targetStart 目标开始偏移和 sourceStart 源开始偏移默认都是 0。 sourceEnd 源结束位置偏移默认是源的长度 buffer.length 。</td></tr>
        <tr><td>20</td><td><b>buf.slice([start[, end]])</b><br>剪切 Buffer 对象，根据 start(默认是 0 ) 和 end (默认是 buffer.length ) 偏移和裁剪了索引。 负的索引是从 buffer 尾部开始计算的。</td></tr>
        <tr><td>21</td><td><b>buf.readUInt8(offset[, noAssert])</b><br>根据指定的偏移量，读取一个有符号 8 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 如果这样 offset 可能会超出buffer 的末尾。默认是 false。</td></tr>
        <tr><td>22</td><td><b>buf.readUInt16LE(offset[, noAssert])</b><br>根据指定的偏移量，使用特殊的 endian 字节序格式读取一个有符号 16 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr>
        <tr><td>23</td><td><b>buf.readUInt16BE(offset[, noAssert])</b><br>根据指定的偏移量，使用特殊的 endian 字节序格式读取一个有符号 16 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr>
        <tr><td>24</td><td><b>buf.readUInt32LE(offset[, noAssert])</b><br>根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数。

            若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr>
        <tr><td>25</td><td><b>buf.readUInt32BE(offset[, noAssert])</b><br>根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数。

            若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr>
        <tr><td>26</td><td><b>buf.readInt8(offset[, noAssert])</b><br>根据指定的偏移量，读取一个 signed 8 位整数。

            若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr>
        <tr><td>27</td><td><b>buf.readInt16LE(offset[, noAssert])</b><br>根据指定的偏移量，使用特殊的 endian 格式读取一个 signed 16 位整数。

            若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr>
        <tr><td>28</td><td><b>buf.readInt16BE(offset[, noAssert])</b><br>根据指定的偏移量，使用特殊的 endian 格式读取一个 signed 16 位整数。

            若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr>
        <tr><td>29</td><td><b>buf.readInt32LE(offset[, noAssert])</b><br>根据指定的偏移量，使用指定的 endian 字节序格式读取一个 signed 32 位整数。

            若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr>
        <tr><td>30</td><td><b>buf.readInt32BE(offset[, noAssert])</b><br>根据指定的偏移量，使用指定的 endian 字节序格式读取一个 signed 32 位整数。

            若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr>
        <tr><td>31</td><td><b>buf.readFloatLE(offset[, noAssert])</b><br>根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位浮点数。

            若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer的末尾。默认是 false。</td></tr>
        <tr><td>32</td><td><b>buf.readFloatBE(offset[, noAssert])</b><br>根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位浮点数。

            若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer的末尾。默认是 false。</td></tr>
        <tr><td>33</td><td><b>buf.readDoubleLE(offset[, noAssert])</b><br>根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位double。

            若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr>
        <tr><td>34</td><td><b>buf.readDoubleBE(offset[, noAssert])</b><br>根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位double。

            若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr>
        <tr><td>35</td><td><b>buf.writeUInt8(value, offset[, noAssert])</b><br>根据传入的 offset 偏移量将 value 写入 buffer。注意：value 必须是一个合法的有符号 8 位整数。

            若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则不要使用。默认是 false。</td></tr>
        <tr><td>36</td><td><b>buf.writeUInt16LE(value, offset[, noAssert])</b><br>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的有符号 16 位整数。

            若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr>
        <tr><td>37</td><td><b>buf.writeUInt16BE(value, offset[, noAssert])</b><br>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的有符号 16 位整数。

            若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr>
        <tr><td>38</td><td><b>buf.writeUInt32LE(value, offset[, noAssert])</b><br>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入buffer。注意：value 必须是一个合法的有符号 32 位整数。

            若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着value 可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr>
        <tr><td>39</td><td><b>buf.writeUInt32BE(value, offset[, noAssert])</b><br>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入buffer。注意：value 必须是一个合法的有符号 32 位整数。

            若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着value 可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr>
        <tr><td>40</td><td><b>buf.writeInt8(value, offset[, noAssert])</b><br根据传入的 offset="" 偏移量将="" value="" 写入="" buffer="" 。注意：value="" 必须是一个合法的="" signed="" 8="" 位整数。="" 若参数="" noassert="" 为="" true="" 将不会验证="" 和="" 偏移量参数。="" 这意味着="" 可能过大，或者="" 可能会超出="" 的末尾从而造成="" 被丢弃。="" 除非你对这个参数非常有把握，否则尽量不要使用。默认是="" false。<="" td=""></br根据传入的></td></tr>
        <tr><td>41</td><td><b>buf.writeInt16LE(value, offset[, noAssert])</b><br>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 16 位整数。

            若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。</td></tr>
        <tr><td>42</td><td><b>buf.writeInt16BE(value, offset[, noAssert])</b><br>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 16 位整数。

            若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。</td></tr>
        <tr><td>43</td><td><b>buf.writeInt32LE(value, offset[, noAssert])</b><br>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 32 位整数。

            若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr>
        <tr><td>44</td><td><b>buf.writeInt32BE(value, offset[, noAssert])</b><br>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 32 位整数。

            若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr>
        <tr><td>45</td><td><b>buf.writeFloatLE(value, offset[, noAssert])</b><br>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value 不是一个 32 位浮点数类型的值时，结果将是不确定的。

            若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr>
        <tr><td>46</td><td><b>buf.writeFloatBE(value, offset[, noAssert])</b><br>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value 不是一个 32 位浮点数类型的值时，结果将是不确定的。

            若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr>
        <tr><td>47</td><td><b>buf.writeDoubleLE(value, offset[, noAssert])</b><br>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个有效的 64 位double 类型的值。

            若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr>
        <tr><td>48</td><td><b>buf.writeDoubleBE(value, offset[, noAssert])</b><br>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个有效的 64 位double 类型的值。

            若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr>
        <tr><td>49</td><td><b>buf.fill(value[, offset][, end])</b><br>使用指定的 value 来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length) ，将会填充整个buffer。</td></tr>
        </tbody></table>
</body>
</html>